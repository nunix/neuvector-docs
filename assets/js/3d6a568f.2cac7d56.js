"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9710],{54635:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>c,contentTitle:()=>t,default:()=>h,frontMatter:()=>n,metadata:()=>l,toc:()=>d});var o=r(74848),i=r(28453);const n={title:"Process Profile Rules",taxonomy:{category:"docs"},slug:"/policy/processrules"},t=void 0,l={id:"policy/processrules/processrules",title:"Process Profile Rules",description:"Policy -> Groups -> Process Profile Rules",source:"@site/docs/05.policy/06.processrules/06.processrules.md",sourceDirName:"05.policy/06.processrules",slug:"/policy/processrules",permalink:"/next/policy/processrules",draft:!1,unlisted:!1,editUrl:"https://github.com/neuvector/docs/edit/main/docs/05.policy/06.processrules/06.processrules.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Process Profile Rules",taxonomy:{category:"docs"},slug:"/policy/processrules"},sidebar:"tutorialSidebar",previous:{title:"Network Rules",permalink:"/next/policy/networkrules"},next:{title:"File Access Rules",permalink:"/next/policy/filerules"}},c={},d=[{value:"Policy -&gt; Groups -&gt; Process Profile Rules",id:"policy---groups---process-profile-rules",level:3},{value:"Zero-drift Process Protection",id:"zero-drift-process-protection",level:4},{value:"Basic Mode Process Protection",id:"basic-mode-process-protection",level:4},{value:"Behavioral Learning Based Process Protection",id:"behavioral-learning-based-process-protection",level:4},{value:"Process Rules for Nodes",id:"process-rules-for-nodes",level:4},{value:"Process Rules for Custom Groups",id:"process-rules-for-custom-groups",level:4},{value:"Process Rules Precedence",id:"process-rules-precedence",level:4},{value:"Discover mode",id:"discover-mode",level:4},{value:"Monitor/Protect mode (new container started in monitor or protect mode)",id:"monitorprotect-mode-new-container-started-in-monitor-or-protect-mode",level:4},{value:"Creating process profile rules",id:"creating-process-profile-rules",level:4},{value:"Built-in Suspicious Process Detection",id:"built-in-suspicious-process-detection",level:4},{value:"Split Mode Process/File Protections",id:"split-mode-processfile-protections",level:3}];function a(e){const s={a:"a",admonition:"admonition",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.h3,{id:"policy---groups---process-profile-rules",children:"Policy -> Groups -> Process Profile Rules"}),"\n",(0,o.jsx)(s.p,{children:"There are two types of Process/File protections in NeuVector. One is Zero-drift, where allowed process and file activity are automatically determined based on the container image, and second is a behavioral learning based. Each can be customized (rules added manually) if desired."}),"\n",(0,o.jsx)(s.admonition,{type:"note",children:(0,o.jsx)(s.p,{children:"There is a limitation when running on systems with the AUFS file system, whereby a race condition can be experienced and the process rules are not enforced for blocking (Protect mode). However, these violations are still reported in the security event logs."})}),"\n",(0,o.jsx)(s.h4,{id:"zero-drift-process-protection",children:"Zero-drift Process Protection"}),"\n",(0,o.jsx)(s.p,{children:"This is the default mode for process and file protections. Zero-drift automatically allows only processes which originate from the parent process that is in the original container image, and does not allow file updates or new files to be installed. When in Discover or Monitor mode, zero-drift will alert on any suspicious process or file activity. In Protect mode, it will block such activity. Zero-drift does not require processes to be learned or added to an allow-list. Disabling zero-drift for a group will cause the process and file rules listed for the group to take effect instead."}),"\n",(0,o.jsx)(s.admonition,{type:"note",children:(0,o.jsx)(s.p,{children:"The process/file rules listed for each group are always applied, even when zero-drift is enabled. This offers a way to add allow/deny exceptions to the base zero-drift protections. Keep in mind that if a group starts in Discover mode, process/file rules can be automatically added to the list, and should be reviewed and edited before moving to Monitor/Protect modes."})}),"\n",(0,o.jsx)(s.p,{children:"The ability to enable/disable zero-drift mode is in the console in Policy -> Groups. Multiple groups can be selected to toggle this setting for all selected groups."}),"\n",(0,o.jsx)(s.h4,{id:"basic-mode-process-protection",children:"Basic Mode Process Protection"}),"\n",(0,o.jsx)(s.p,{children:"Zero-drift can be disabled, switching to Basic process protection. Basic protection enforces process/file activity based on the listed process and/or file rules for each Group. This means that there must be a list of process rules and/or file rules in place for protection to occur. Rules can be auto-created through Behavioral Learning while in Discover mode, manually created through the console or rest API, or programmatically created by applying a CRD. With Basic enabled if there are no rules in place, all activity will be alerted/blocked while in Monitor or Protect modes."}),"\n",(0,o.jsx)(s.h4,{id:"behavioral-learning-based-process-protection",children:"Behavioral Learning Based Process Protection"}),"\n",(0,o.jsx)(s.p,{children:"Process profile rules use baseline learning to profile the processes that should be allowed to run in a group of containers (i.e. a Group). Under normal conditions in a microservices environment, for containers with a particular image, only a limited set of processes by specific users would run. If the container is attacked, the malicious attacker would likely initiate some new programs commonly not seen in this container. These abnormal events can be detected by NeuVector and alerts and actions generated (see also Response Rules)."}),"\n",(0,o.jsx)(s.p,{children:"Process baseline information will be learned and recorded when the service Group is in Discover (learning) mode. When in Monitor or Protect mode, if a process that has not been seen before is newly started, or an old process is started by a different user than before, the event will be detected and alerted as a suspicious process in Monitor mode or alerted and blocked in Protect mode. Users can modify the learned profile to allow or deny (whitelist or blacklist) processes manually if needed."}),"\n",(0,o.jsx)(s.p,{children:"Note that in addition to baseline processes, NeuVector has built-in detection of common suspicious processes such as nmap, reverse shell etc. These will be detected and alerted/blocked unless explicitly white listed for each container service."}),"\n",(0,o.jsx)(s.admonition,{title:"important",type:"warning",children:(0,o.jsx)(s.p,{children:"Kubernetes liveness probes are automatically allowed, and added to the learned process rules even in Monitor/Protect mode."})}),"\n",(0,o.jsx)(s.h4,{id:"process-rules-for-nodes",children:"Process Rules for Nodes"}),"\n",(0,o.jsx)(s.p,{children:"The special reserved group 'nodes' can be configured to enforce process profile rules on each node (host) in the cluster. Select the group 'nodes' and review the process rules, editing if required. Then switch the protection mode to Monitor or Protect. The 'local' (learned) process rule list is a combination of all processes from all nodes in the cluster while in Discover mode."}),"\n",(0,o.jsx)(s.h4,{id:"process-rules-for-custom-groups",children:"Process Rules for Custom Groups"}),"\n",(0,o.jsx)(s.p,{children:"For user defined custom Groups, process rules, if desired, must be manually added. Custom Groups do not learn process rules automatically."}),"\n",(0,o.jsx)(s.h4,{id:"process-rules-precedence",children:"Process Rules Precedence"}),"\n",(0,o.jsx)(s.p,{children:"Process rules can exist for user defined custom Groups as well as auto-learned Groups. Rules created for custom Groups take precedence over rules for auto-learned Groups."}),"\n",(0,o.jsx)(s.p,{children:"For the process rule list within any Group, the rule order in the console determines its precedence. The top rules listed are matched first before the ones below it."}),"\n",(0,o.jsx)(s.p,{children:"Process rules with name and path both containing wildcards take precedence over other rules to Allow action. A Deny action is not allowed with both wildcards to avoid blocking all processes."}),"\n",(0,o.jsx)(s.p,{children:"Process rules with a Deny action and wildcard in the name will take precedence over Allow actions with wildcard in the name."}),"\n",(0,o.jsx)(s.h4,{id:"discover-mode",children:"Discover mode"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"All new processed are profiled with action allow"}),"\n",(0,o.jsx)(s.li,{children:"Users can change the action into 'deny' for generating alert or blocking when same new process is started"}),"\n",(0,o.jsx)(s.li,{children:"Users can create a profile for a process with either allow or deny"}),"\n",(0,o.jsx)(s.li,{children:"Process profile rules can contain name and/or path"}),"\n",(0,o.jsx)(s.li,{children:"Wildcard * can be used to match all for name or path"}),"\n"]}),"\n",(0,o.jsx)(s.admonition,{type:"note",children:(0,o.jsx)(s.p,{children:"A suspicious process (built-in detect), such as nmap, ncat, etc., is reported as a suspicious process event and will NOT be learned. If a service needs this process, the process needs to be added with an 'allow' profile rule explicitly."})}),"\n",(0,o.jsx)(s.h4,{id:"monitorprotect-mode-new-container-started-in-monitor-or-protect-mode",children:"Monitor/Protect mode (new container started in monitor or protect mode)"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"Every new process generates an alert"}),"\n",(0,o.jsx)(s.li,{children:"Process profile rules can contain name and/or path"}),"\n",(0,o.jsx)(s.li,{children:"Wildcard * can be used to match all for name or path"}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:"If a) process matches a deny rule, or b) process is not in the list of allow rules, then:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"In Monitor mode, alerts will be generated"}),"\n",(0,o.jsx)(s.li,{children:"In Protect mode, processes will be blocked and alerts generated"}),"\n"]}),"\n",(0,o.jsx)(s.admonition,{type:"note",children:(0,o.jsx)(s.p,{children:"Container platforms with the AUFS storage driver will introduce a delay in blocking mechanism due to the driver\u2019s limitations."})}),"\n",(0,o.jsx)(s.admonition,{type:"note",children:(0,o.jsx)(s.p,{children:"In Protect mode, system containers such as Kubernetes ones, will not enable the block action but will generate a process violation event if there is a process violation."})}),"\n",(0,o.jsx)(s.h4,{id:"creating-process-profile-rules",children:"Creating process profile rules"}),"\n",(0,o.jsx)(s.p,{children:"Multiple rules can be created for the same process. The rules are executed sequentially and the first matching rule will be executed."}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"Click Add rule (+) from process profile rules tab"}),"\n",(0,o.jsx)(s.li,{children:"Process profile rules can contain name and/or path"}),"\n",(0,o.jsx)(s.li,{children:"Wildcard * can be used to match all for name or path"}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:"Example:  To allow the ping process to run from any directory"}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.img,{alt:"pingRule",src:r(41597).A+"",width:"1448",height:"534"})}),"\n",(0,o.jsx)(s.p,{children:"Violations will be logged in Notifications -> Security Events."}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsx)(s.img,{alt:"violation",src:r(4427).A+"",width:"1022",height:"275"})}),"\n",(0,o.jsx)(s.h4,{id:"built-in-suspicious-process-detection",children:"Built-in Suspicious Process Detection"}),"\n",(0,o.jsx)(s.p,{children:"The following built-in detections are automatically enabled in NeuVector."}),"\n",(0,o.jsxs)(s.table,{children:[(0,o.jsx)(s.thead,{children:(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.th,{children:"Process"}),(0,o.jsx)(s.th,{children:"Direction"}),(0,o.jsx)(s.th,{children:"Reported name"})]})}),(0,o.jsxs)(s.tbody,{children:[(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"nmap"}),(0,o.jsx)(s.td,{children:"outgoing"}),(0,o.jsx)(s.td,{children:"port scanner"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"nc"}),(0,o.jsx)(s.td,{children:"outgoing"}),(0,o.jsx)(s.td,{children:"netcat process"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"ncat"}),(0,o.jsx)(s.td,{children:"outgoing"}),(0,o.jsx)(s.td,{children:"netcat process"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"netcat"}),(0,o.jsx)(s.td,{children:"outgoing"}),(0,o.jsx)(s.td,{children:"netcat process"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"sshd"}),(0,o.jsx)(s.td,{children:"incoming"}),(0,o.jsx)(s.td,{children:"ssh from remote"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"ssh"}),(0,o.jsx)(s.td,{children:"outgoing"}),(0,o.jsx)(s.td,{children:"ssh to remote"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"scp"}),(0,o.jsx)(s.td,{children:"outgoing"}),(0,o.jsx)(s.td,{children:"secure copy"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"telnet"}),(0,o.jsx)(s.td,{children:"outgoing"}),(0,o.jsx)(s.td,{children:"telnet to remote"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"in.telnetd"}),(0,o.jsx)(s.td,{children:"incoming"}),(0,o.jsx)(s.td,{children:"telnet from remote"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"iodine"}),(0,o.jsx)(s.td,{children:"outgoing"}),(0,o.jsx)(s.td,{children:"dns tunneling"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"iodined"}),(0,o.jsx)(s.td,{children:"incoming"}),(0,o.jsx)(s.td,{children:"dns tunneling"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"dnscat"}),(0,o.jsx)(s.td,{children:"outgoing"}),(0,o.jsx)(s.td,{children:"dns tunneling"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"dns2tcpc"}),(0,o.jsx)(s.td,{children:"outgoing"}),(0,o.jsx)(s.td,{children:"dns tunneling"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"dns2tcpd"}),(0,o.jsx)(s.td,{children:"incoming"}),(0,o.jsx)(s.td,{children:"dns tunneling"})]}),(0,o.jsxs)(s.tr,{children:[(0,o.jsx)(s.td,{children:"socat"}),(0,o.jsx)(s.td,{children:"outgoing"}),(0,o.jsx)(s.td,{children:"relay process"})]})]})]}),"\n",(0,o.jsx)(s.p,{children:"In addition the following detections are enabled:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"docker cp"}),"\n",(0,o.jsx)(s.li,{children:"root privilege escalation (user role into root role)"}),"\n",(0,o.jsx)(s.li,{children:"tunnel: reverse shell (triggered when stdin and stdout are redirected to the same socket)"}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:"Suspicious processes are alerted when in Discover or Monitor mode, and blocked when in Protect mode. Detection applies to containers as well as hosts, with the exception of 'sshd' which is not considered suspicious on hosts. Processes listed above can be added to the Allow List for containers (Groups) including hosts if it should be allowed."}),"\n",(0,o.jsx)(s.h3,{id:"split-mode-processfile-protections",children:"Split Mode Process/File Protections"}),"\n",(0,o.jsxs)(s.p,{children:["Container Groups can have Process/File rules in a different mode than Network rules, as described ",(0,o.jsx)(s.a,{href:"/policy/modes#network-service-policy-mode",children:"here"}),"."]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(a,{...e})}):a(e)}},41597:(e,s,r)=>{r.d(s,{A:()=>o});const o=r.p+"assets/images/ping-51a4c961d6d2b611a726b254dbeacba5.png"},4427:(e,s,r)=>{r.d(s,{A:()=>o});const o=r.p+"assets/images/process_event-de6f14d1654fef2d89d19358f8143523.png"},28453:(e,s,r)=>{r.d(s,{R:()=>t,x:()=>l});var o=r(96540);const i={},n=o.createContext(i);function t(e){const s=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),o.createElement(n.Provider,{value:s},e.children)}}}]);