"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[703],{77287:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var o=n(74848),r=n(28453);const i={title:"Network Rules",taxonomy:{category:"docs"},slug:"/policy/networkrules"},s=void 0,l={id:"policy/networkrules/networkrules",title:"Network Rules",description:"Policy: Network Rules",source:"@site/versioned_docs/version-5.2/05.policy/05.networkrules/05.networkrules.md",sourceDirName:"05.policy/05.networkrules",slug:"/policy/networkrules",permalink:"/5.2/policy/networkrules",draft:!1,unlisted:!1,editUrl:"https://github.com/neuvector/docs/edit/main/versioned_docs/version-5.2/05.policy/05.networkrules/05.networkrules.md",tags:[],version:"5.2",sidebarPosition:5,frontMatter:{title:"Network Rules",taxonomy:{category:"docs"},slug:"/policy/networkrules"},sidebar:"tutorialSidebar",previous:{title:"Groups",permalink:"/5.2/policy/groups"},next:{title:"Process Profile Rules",permalink:"/5.2/policy/processrules"}},a={},c=[{value:"Policy: Network Rules",id:"policy-network-rules",level:3},{value:"Egress Control: Allowing Connections to Trusted Internal Services on Other Networks",id:"egress-control-allowing-connections-to-trusted-internal-services-on-other-networks",level:3},{value:"Ingress IP Policy Based on XFF-FORWARDED-FOR",id:"ingress-ip-policy-based-on-xff-forwarded-for",level:4},{value:"Special Enforcement for Istio ServiceEntry Destinations",id:"special-enforcement-for-istio-serviceentry-destinations",level:4},{value:"Virtual Host Based Network Policy",id:"virtual-host-based-network-policy",level:4},{value:"Split Mode Network Protections",id:"split-mode-network-protections",level:3},{value:"Built-In Network Threat Detection",id:"built-in-network-threat-detection",level:3}];function d(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h3,{id:"policy-network-rules",children:"Policy: Network Rules"}),"\n",(0,o.jsx)(t.p,{children:"NeuVector automatically creates Network Rules from your running applications in Discover mode. You can also manually add them in any mode, Discover, Monitor, or Protect. Rules can be added or edited from the CLI or REST API."}),"\n",(0,o.jsx)(t.p,{children:"NeuVector uses a declarative policy which consist of rules which govern allowed and denied application layer connections. NeuVector analyzes and protects based on not only IP address and port, but by determining the actual network behavior based on application protocols. This enables NeuVector to automatically protect any new application containers regardless of IP address and port."}),"\n",(0,o.jsx)(t.p,{children:"Network rules specify ALLOWED or DENIED behavior for your applications. These rules determine what connections are normal behavior for your services as well as what are violations. You can delete automatically \u2018learned\u2019 rules as well as add new rules to your policy."}),"\n",(0,o.jsx)(t.admonition,{title:"important",type:"warning",children:(0,o.jsx)(t.p,{children:"Network rules are enforced in the order that they appear in the list, from top to bottom. To re-order the rules, select the rule you want to move, then you will see a 'Move to' box appear at the top, and you can move the selected rule to the position before or after a specified rule."})}),"\n",(0,o.jsx)(t.admonition,{title:"important",type:"warning",children:(0,o.jsx)(t.p,{children:"If you edit (add, delete, change) rules, your changes are NOT applied until you click the Save button at the top. If you exit this page without deploying your changes, they will be lost."})}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)("strong",{children:"Adding New Rules"}),"\nAdd a rule using the \u2018+\u2019 either below another rule in the right column, or using the button in the lower right."]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"ID"})}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"(Optional) Enter a number. Network rules are initially ordered from lowest to highest, but rule order can be changed by dragging and dropping them in the list."}),"\n"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"From"})}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Specify the GROUP from where the connection will originate. Start typing and NeuVector will match any previously discovered groups, as well as any new groups defined."}),"\n"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"To"})}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Specify the destination GROUP where these connections are allowed or denied."}),"\n"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"Applications"})}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Enter applications for NeuVector to allow or deny. NeuVector understands deep application behavior and will analyze the payload to determine application protocols. Protocols include HTTP, HTTPS, SSL, SSH, DNS, DNCP, NTP, TFTP, ECHO, RTSP, SIP, MySQL, Redis, Zookeeper, Cassandra, MongoDB, PostgresSQL, Kafka, Couchbase, ActiveMQ, ElasticSearch, RabbitMQ, Radius, VoltDB, Consul, Syslog, Etcd, Spark, Apache, Nginx, Jetty, NodeJS, Oracle, MSSQL, Memcached and gRPC."}),"\n"]}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsx)(t.p,{children:"To select Any/All, leave this field blank"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"Ports"})}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"If there are specific ports to limit this rule to, enter them here. For ICMP traffic, enter icmp."}),"\n"]}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsx)(t.p,{children:"To select Any/All, leave this field blank"})}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.strong,{children:"Deny/Allow"})}),"\n"]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsx)(t.p,{children:"Indicate whether this rule is to Allow this type of connection, or Deny it."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"If Deny is selected, NeuVector will log this as a violation while in Monitor mode, and will block this while in Protect mode. The default action is to Deny a connection (log violation only if in Monitor mode) if no rule matches it."}),"\n",(0,o.jsx)(t.p,{children:"Don\u2019t forget to Deploy/Update if you make any changes!"}),"\n",(0,o.jsx)(t.h3,{id:"egress-control-allowing-connections-to-trusted-internal-services-on-other-networks",children:"Egress Control: Allowing Connections to Trusted Internal Services on Other Networks"}),"\n",(0,o.jsx)(t.p,{children:"A common use case for customizing rules is to allow a container service to connect to a network outside of the NeuVector managed cluster\u2019s network. In many cases, since NeuVector does not recognize this network it will classify it as an \u2018External\u2019 network, even if it is an internal network."}),"\n",(0,o.jsx)(t.p,{children:"To allow containers to connect to services on other internal networks, first create a group, then a rule for it."}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Create a Group. In Policy -> Groups, click to add a new Group. Name the group (e.g. internal) then specify the criteria for the group. For example, specify the DNS name, IP address or address range of the internal services. Save the new group."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Create a Rule. In Policy -> Rules, click to add a new rule. Select the group representing the container From which the connections will originate, then the To group (e.g. internal). You can further refine the rule with specific protocols or ports, or leave blank. Make sure the selector is set to Allow (green)."}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Be sure to click Deploy to save the new rule."}),"\n",(0,o.jsx)(t.p,{children:"Finally, review the list of rules to make sure the new rule is in the order and priority desired. Rules are applied from top to bottom."}),"\n",(0,o.jsx)(t.h4,{id:"ingress-ip-policy-based-on-xff-forwarded-for",children:"Ingress IP Policy Based on XFF-FORWARDED-FOR"}),"\n",(0,o.jsx)(t.p,{children:"In a Kubernetes cluster, an application can be exposed to the outside of the cluster by a NodePort, LoadBalancer or Ingress services. These services typically replace the source IP while doing the Source NAT (SNAT) on the packets. As the original source IP is masqueraded, this prevents NeuVector from recognizing the connection is actually from the 'external'."}),"\n",(0,o.jsxs)(t.p,{children:["In order to preserve the original source IP address, the user needs to add the following line to the exposed services, in the 'spec' section of the external facing load balancer or ingress controller. (Ref: ",(0,o.jsx)(t.a,{href:"https://kubernetes.io/docs/tutorials/services/source-ip/",children:"https://kubernetes.io/docs/tutorials/services/source-ip/"}),")"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-json",children:'"externalTrafficPolicy":"Local"\n'})}),"\n",(0,o.jsx)(t.p,{children:"Many implementations of LoadBalancer services and Ingress controllers will add the X-FORWARDED-FOR line to the HTTP request header to communicate the real source IP to the backend applications. This product can recognize this set of HTTP headers, identify the original source IP and enforce the policy according to that."}),"\n",(0,o.jsx)(t.p,{children:'This improvement created some unexpected issues in some setup. If the above line has been added to the exposed services and NeuVector network policies have been created in a way that expect the network connections are coming from internal proxy/ingress services, because we now identify the connections are from "external" to the cluster, normal application traffic might trigger alerts or get blocked if the applications are put in "Protect" mode.'}),"\n",(0,o.jsx)(t.p,{children:'A switch is available to disable this feature. Disabling it tells NeuVector not to identify that the connection is from "external" using X-FORWARDED-FOR headers. By default this is enabled, and the X-FORWARDED-FOR header is used in policy enforcement. To disable it, go to Settings -> Configuration, and disable the "X-Forwarded-For based policy match" setting.'}),"\n",(0,o.jsx)(t.h4,{id:"special-enforcement-for-istio-serviceentry-destinations",children:"Special Enforcement for Istio ServiceEntry Destinations"}),"\n",(0,o.jsx)(t.p,{children:"Egress network policy enforcement functionality was added in version 5.1.0 for pods to ServiceEntry destinations declared with Istio. Typically, a ServiceEntry defines how an external service referred by DNS name is resolved to a destination IP. Prior to v5.1, NeuVector could not detect and enforce rules for connections to a ServiceEntry, so all connections were classified as External. With 5.1, rules can be enforced for specific ServiceEntry destinations. Implicit violations will be reported for newly visible traffic if allow rules don't exist. These rules can be learned and auto-created under Discover mode. To allow this traffic, you can put the group into discover mode or create a custom group with destination addresses (or DNS name) and add a new network rule to this destination to allow the traffic."}),"\n",(0,o.jsx)(t.h4,{id:"virtual-host-based-network-policy",children:"Virtual Host Based Network Policy"}),"\n",(0,o.jsxs)(t.p,{children:["Custom groups can support virtual host based address groups. This enables a use case where two different FQDN addresses are resolved to the same IP address, but different rules for each FQDN should be enforced. A new custom group with \u2018address=vh",":xxx",".yyy\u2019 can be created using the \u2018vh:\u2019 indicator to enable this protection. A network rule can then use the custom group as the \u2018From\u2019 source based on the virtual hostname (instead of resolved IP address) to enforce different rules for virtual hosts."]}),"\n",(0,o.jsx)(t.h3,{id:"split-mode-network-protections",children:"Split Mode Network Protections"}),"\n",(0,o.jsxs)(t.p,{children:["Container Groups can have Process/File rules in a different mode than Network rules, as described ",(0,o.jsx)(t.a,{href:"/policy/modes#network-service-policy-mode",children:"here"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"built-in-network-threat-detection",children:"Built-In Network Threat Detection"}),"\n",(0,o.jsx)(t.p,{children:"NeuVector automatically detects certain network attacks, regardless of protection mode. In Discover and Monitor mode, these threats will be alerted and can be found in Notifications -> Security Events. In Protect mode, these will alerted as well as blocked. Response rules can be created based on threat detection as well."}),"\n",(0,o.jsx)(t.p,{children:"Note that customized network threat detection can be configured through the WAF rules section."}),"\n",(0,o.jsx)(t.p,{children:"NeuVector includes the following detections for threats:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"Apache Struts RCE attack"}),"\n",(0,o.jsx)(t.li,{children:"Cipher Overflow attack"}),"\n",(0,o.jsx)(t.li,{children:"Detect HTTP negative content-length buffer overflow"}),"\n",(0,o.jsx)(t.li,{children:"Detect MySQL access deny"}),"\n",(0,o.jsx)(t.li,{children:"Detect SSH version 1, 2 or 3"}),"\n",(0,o.jsx)(t.li,{children:"Detect SSL TLS v1.0, v1.1 (requires environment variable to enable)"}),"\n",(0,o.jsx)(t.li,{children:"DNS buffer overflow attack"}),"\n",(0,o.jsx)(t.li,{children:"DNS flood DDOS attack"}),"\n",(0,o.jsx)(t.li,{children:"DNS null type attack"}),"\n",(0,o.jsx)(t.li,{children:"DNS tunneling attack"}),"\n",(0,o.jsx)(t.li,{children:"DNS zone transfer attack"}),"\n",(0,o.jsx)(t.li,{children:"HTTP Slowloris DDOS attack"}),"\n",(0,o.jsx)(t.li,{children:"HTTP smuggling attack"}),"\n",(0,o.jsx)(t.li,{children:"ICMP flood attack"}),"\n",(0,o.jsx)(t.li,{children:"ICMP tunneling attack"}),"\n",(0,o.jsx)(t.li,{children:"IP Teardrop attack"}),"\n",(0,o.jsx)(t.li,{children:"Kubernetes man-in-the-middle attack per CVE-2020-8554"}),"\n",(0,o.jsx)(t.li,{children:"PING death attack"}),"\n",(0,o.jsx)(t.li,{children:"SQL injection attack"}),"\n",(0,o.jsx)(t.li,{children:"SSL heartbleed attack"}),"\n",(0,o.jsx)(t.li,{children:"SYN flood attack"}),"\n",(0,o.jsx)(t.li,{children:"TCP small window attack"}),"\n",(0,o.jsx)(t.li,{children:"TCP split handshake attack"}),"\n",(0,o.jsx)(t.li,{children:"TCP Small MSS attack"}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var o=n(96540);const r={},i=o.createContext(r);function s(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);